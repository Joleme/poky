From b14baef10a7eb0a22e05e37e076174ebc51a0f6a Mon Sep 17 00:00:00 2001
From: "Todd C. Miller" <Todd.Miller@sudo.ws>
Date: Wed, 29 Jan 2020 20:15:21 -0700
Subject: [PATCH] Fix a buffer overflow when pwfeedback is enabled and input is
 a not a tty. In getln() if the user enters ^U (erase line) and the write(2)
 fails, the remaining buffer size is reset but the current pointer is not.
 While here, fix an incorrect break for erase when write(2) fails. Also
 disable pwfeedback when input is not a tty as it cannot work. CVE-2019-18634
 Credit: Joe Vennix from Apple Information Security.

--HG--
branch : 1.8
[Salvatore Bonaccorso: Backport to 1.8.19p1. Changes from ab2cba0f5d8b ("Print
a warning for password read issues. Issues include: timeout at the password
prompt, read error while reading the password, and EOF reading the password.")
upstream in 1.8.26 changes signature of getln function.]

Upstream-Status: Backport http://deb.debian.org/debian/pool/main/s/sudo/sudo_1.8.19p1-2.1+deb9u2.debian.tar.xz
CVE: CVE-2019-18634
Signed-off-by: Milan Shah <mshah@mvista.com>
---
 src/tgetpass.c | 21 +++++++++++++--------
 1 file changed, 13 insertions(+), 8 deletions(-)

diff --git a/src/tgetpass.c b/src/tgetpass.c
index c84f5de..8a78f5a 100644
--- a/src/tgetpass.c
+++ b/src/tgetpass.c
@@ -48,7 +48,7 @@ static volatile sig_atomic_t signo[NSIG];
 
 static bool tty_present(void);
 static void tgetpass_handler(int);
-static char *getln(int, char *, size_t, int);
+static char *getln(int, char *, size_t, bool);
 static char *sudo_askpass(const char *, const char *);
 
 static int
@@ -90,6 +90,7 @@ tgetpass(const char *prompt, int timeout, int flags,
     static const char *askpass;
     static char buf[SUDO_CONV_REPL_MAX + 1];
     int i, input, output, save_errno, neednl = 0, need_restart;
+    bool feedback = ISSET(flags, TGP_MASK);
     debug_decl(tgetpass, SUDO_DEBUG_CONV)
 
     (void) fflush(stdout);
@@ -136,7 +137,7 @@ restart:
      */
     if (!ISSET(flags, TGP_ECHO)) {
 	for (;;) {
-	    if (ISSET(flags, TGP_MASK))
+	    if (feedback)
 		neednl = sudo_term_cbreak(input);
 	    else
 		neednl = sudo_term_noecho(input);
@@ -151,6 +152,10 @@ restart:
 	}
     }
 
+    /* Only use feedback mode when we can disable echo. */
+    if (!neednl)
+	    feedback = false;
+
     /*
      * Catch signals that would otherwise cause the user to end
      * up with echo turned off in the shell.
@@ -175,7 +180,7 @@ restart:
 
     if (timeout > 0)
 	alarm(timeout);
-    pass = getln(input, buf, sizeof(buf), ISSET(flags, TGP_MASK));
+    pass = getln(input, buf, sizeof(buf), feedback);
     alarm(0);
     save_errno = errno;
 
@@ -294,7 +299,7 @@ sudo_askpass(const char *askpass, const char *prompt)
 extern int sudo_term_erase, sudo_term_kill;
 
 static char *
-getln(int fd, char *buf, size_t bufsiz, int feedback)
+getln(int fd, char *buf, size_t bufsiz, bool feedback)
 {
     size_t left = bufsiz;
     ssize_t nr = -1;
@@ -316,15 +321,15 @@ getln(int fd, char *buf, size_t bufsiz, int feedback)
 		while (cp > buf) {
 		    if (write(fd, "\b \b", 3) == -1)
 			break;
-		    --cp;
+		    cp--;
 		}
+		cp = buf;
 		left = bufsiz;
 		continue;
 	    } else if (c == sudo_term_erase) {
 		if (cp > buf) {
-		    if (write(fd, "\b \b", 3) == -1)
-			break;
-		    --cp;
+		    ignore_result(write(fd, "\b \b", 3));
+		    cp--;
 		    left++;
 		}
 		continue;
-- 
2.7.4

