From e662c5cb2c7f27a6ae5cbe1f91aa57f22a680765 Mon Sep 17 00:00:00 2001
From: Daniel Axtens <dja@axtens.net>
Date: Tue, 4 Dec 2018 14:29:42 +1100
Subject: [PATCH] Skip 0-length ACL fields

Currently, it is possible to create an archive that crashes bsdtar
with a malformed ACL:

Program received signal SIGSEGV, Segmentation fault.
archive_acl_from_text_l (acl=<optimised out>, text=0x7e2e92 "", want_type=<optimised out>, sc=<optimised out>) at libarchive/archive_acl.c:1726
1726				switch (*s) {
(gdb) p n
$1 = 1
(gdb) p field[n]
$2 = {start = 0x0, end = 0x0}

Stop this by checking that the length is not zero before beginning
the switch statement.

I am pretty sure this is the bug mentioned in the qsym paper [1],
and I was able to replicate it with a qsym + AFL + afl-rb setup.

[1] https://www.usenix.org/conference/usenixsecurity18/presentation/yun

Upstream-Status: Backport
CVE: CVE-2018-1000879

Signed-off-by: Rahul Chauhan <rahulk@mvista.com>
---
 libarchive/archive_acl.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/libarchive/archive_acl.c b/libarchive/archive_acl.c
index b8b6b63..9c5f4a2 100644
--- a/libarchive/archive_acl.c
+++ b/libarchive/archive_acl.c
@@ -1705,6 +1705,11 @@ archive_acl_from_text_l(struct archive_acl *acl, const char *text,
			st = field[n].start + 1;
			len = field[n].end - field[n].start;

+			if (len == 0) {
+				ret = ARCHIVE_WARN;
+				continue;
+			}
+
			switch (*s) {
			case 'u':
				if (len == 1 || (len == 4
--
2.7.4

