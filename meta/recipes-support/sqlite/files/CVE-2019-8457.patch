
Upstream-Status: Backport 
https://www.sqlite.org/src/vpatch?from=55be6d0a9fa8a64b&to=90acdbfce9c08858

Kept old name and backport the _new() only
selected parts from https://repo.or.cz/sqlite.git/commitdiff/b3e4b9d81aab53a6ccc9c766f5c37d16c892485d
CVE: CVE-2019-8457
Signed-off-by: Armin Kuster <akuster@mvista.com>

Index: sqlite-autoconf-3200000/sqlite3.c
===================================================================
--- sqlite-autoconf-3200000.orig/sqlite3.c
+++ sqlite-autoconf-3200000/sqlite3.c
@@ -8004,8 +8004,7 @@ SQLITE_API int sqlite3_test_control(int
 #define SQLITE_TESTCTRL_IMPOSTER                25
 #define SQLITE_TESTCTRL_LAST                    25
 
-/*
-** CAPI3REF: SQLite Runtime Status
+/** CAPI3REF: SQLite Runtime Status
 **
 ** ^These interfaces are used to retrieve runtime status information
 ** about the performance of SQLite, and optionally to reset various
@@ -18136,6 +18135,54 @@ SQLITE_PRIVATE void sqlite3VectorErrorMs
 SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt);
 #endif
 
+/*
+** CAPI3REF: Finalize A Dynamic String
+** DESTRUCTOR: sqlite3_str
+**
+** The [sqlite3_str_finish(X)] interface destroys the sqlite3_str object X
+** and returns a pointer to a memory buffer obtained from [sqlite3_malloc64()]
+** that contains the constructed string.  The calling application should
+** pass the returned value to [sqlite3_free()] to avoid a memory leak.
+** The [sqlite3_str_finish(X)] interface may return a NULL pointer if any
+** errors were encountered during construction of the string.  The
+** [sqlite3_str_finish(X)] interface will also return a NULL pointer if the
+** string in [sqlite3_str] object X is zero bytes long.
+*/
+char *sqlite3_str_finish(StrAccum*);
+
+/*
+** CAPI3REF: Status Of A Dynamic String
+** METHOD: StrAccum 
+**
+** These interfaces return the current status of an [sqlite3_str] object.
+**
+** If any prior errors have occurred while constructing the dynamic string
+** in sqlite3_str X, then the [sqlite3_str_errcode(X)] method will return
+** an appropriate error code.  The [sqlite3_str_errcode(X)] method returns
+** [SQLITE_NOMEM] following any out-of-memory error, or
+** [SQLITE_TOOBIG] if the size of the dynamic string exceeds
+** [SQLITE_MAX_LENGTH], or [SQLITE_OK] if there have been no errors.
+**
+** The [sqlite3_str_length(X)] method returns the current length, in bytes,
+** of the dynamic string under construction in [sqlite3_str] object X.
+** The length returned by [sqlite3_str_length(X)] does not include the
+** zero-termination byte.
+**
+** The [sqlite3_str_value(X)] method returns a pointer to the current
+** content of the dynamic string under construction in X.  The value
+** returned by [sqlite3_str_value(X)] is managed by the sqlite3_str object X
+** and might be freed or altered by any subsequent method on the same
+** [sqlite3_str] object.  Applications must not used the pointer returned
+** [sqlite3_str_value(X)] after any subsequent method call on the same
+** object.  Applications may change the content of the string returned
+** by [sqlite3_str_value(X)] as long as they do not write into any bytes
+** outside the range of 0 to [sqlite3_str_length(X)] and do not read or
+** write any byte after any subsequent sqlite3_str method call.
+*/
+int sqlite3_str_errcode(StrAccum*);
+int sqlite3_str_length(StrAccum*);
+char *sqlite3_str_value(StrAccum*);
+
 #endif /* SQLITEINT_H */
 
 /************** End of sqliteInt.h *******************************************/
@@ -26489,6 +26536,34 @@ SQLITE_PRIVATE char *sqlite3StrAccumFini
   return p->zText;
 }
 
+/* Finalize a string created using sqlite3_str_new().
+*/
+char *sqlite3_str_finish(StrAccum *p){
+  char *z;
+  if( p ){
+    z = sqlite3StrAccumFinish(p);
+    sqlite3DbFree(p->db, p);
+  }else{
+    z = 0;
+  }
+  return z;
+}
+
+/* Return any error code associated with p */
+int sqlite3_str_errcode(StrAccum *p){
+  return p ? p->accError : STRACCUM_NOMEM;
+}
+
+/* Return the current length of p in bytes */
+int sqlite3_str_length(StrAccum *p){
+  return p ? p->nChar : 0;
+}
+
+/* Return the current value for p */
+char *sqlite3_str_value(StrAccum *p){
+  return p ? p->zText : 0;
+}
+
 /*
 ** Reset an StrAccum string.  Reclaim all malloced memory.
 */
@@ -26525,6 +26600,15 @@ SQLITE_PRIVATE void sqlite3StrAccumInit(
   p->printfFlags = 0;
 }
 
+/* Allocate and initialize a new dynamic string object */
+StrAccum *sqlite3_str_new(sqlite3 *db){
+  StrAccum *p = sqlite3DbMallocRaw(db, sizeof(*p));
+  if( p ){
+    sqlite3StrAccumInit(p, db, 0, 0, SQLITE_MAX_LENGTH);
+  }
+  return p;
+}
+
 /*
 ** Print into memory obtained from sqliteMalloc().  Use the internal
 ** %-conversion extensions.
@@ -168798,49 +168882,47 @@ static int rtreeInit(
 ** <num-dimension>*2 coordinates.
 */
 static void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){
-  char *zText = 0;
   RtreeNode node;
   Rtree tree;
   int ii;
+  int nData;
+  int errCode;
+  StrAccum *pOut;
 
   UNUSED_PARAMETER(nArg);
   memset(&node, 0, sizeof(RtreeNode));
   memset(&tree, 0, sizeof(Rtree));
   tree.nDim = (u8)sqlite3_value_int(apArg[0]);
+  if( tree.nDim<1 || tree.nDim>5 ) return;
   tree.nDim2 = tree.nDim*2;
   tree.nBytesPerCell = 8 + 8 * tree.nDim;
   node.zData = (u8 *)sqlite3_value_blob(apArg[1]);
-
+  nData = sqlite3_value_bytes(apArg[1]);
+  if( nData<4 ) return;
+  if( nData<NCELL(&node)*tree.nBytesPerCell ) return;
+//armin 
+  pOut = sqlite3_str_new(0);
   for(ii=0; ii<NCELL(&node); ii++){
-    char zCell[512];
-    int nCell = 0;
     RtreeCell cell;
     int jj;
 
     nodeGetCell(&tree, &node, ii, &cell);
-    sqlite3_snprintf(512-nCell,&zCell[nCell],"%lld", cell.iRowid);
-    nCell = (int)strlen(zCell);
+    if( ii>0 ) sqlite3StrAccumAppend(pOut, " ", 1);
+    sqlite3XPrintf(pOut, "{%lld", cell.iRowid);
     for(jj=0; jj<tree.nDim2; jj++){
 #ifndef SQLITE_RTREE_INT_ONLY
-      sqlite3_snprintf(512-nCell,&zCell[nCell], " %g",
-                       (double)cell.aCoord[jj].f);
+      sqlite3XPrintf(pOut, " %g", (double)cell.aCoord[jj].f);
 #else
-      sqlite3_snprintf(512-nCell,&zCell[nCell], " %d",
-                       cell.aCoord[jj].i);
+      sqlite3XPrintf(pOut, " %d", cell.aCoord[jj].i);
 #endif
-      nCell = (int)strlen(zCell);
     }
 
-    if( zText ){
-      char *zTextNew = sqlite3_mprintf("%s {%s}", zText, zCell);
-      sqlite3_free(zText);
-      zText = zTextNew;
-    }else{
-      zText = sqlite3_mprintf("{%s}", zCell);
-    }
+    sqlite3StrAccumAppend(pOut, "}", 1);
   }
   
-  sqlite3_result_text(ctx, zText, -1, sqlite3_free);
+  errCode = sqlite3_str_errcode(pOut);
+  sqlite3_result_text(ctx, sqlite3_str_finish(pOut), -1, sqlite3_free);
+  sqlite3_result_error_code(ctx, errCode);
 }
 
 /* This routine implements an SQL function that returns the "depth" parameter
